import { describe, it, beforeAll, afterAll, expect } from 'vitest'
import type { Client, User } from '@/payload-types'
import type { Payload, PayloadRequest } from 'payload'
import { createTestEnvironment } from '../utils/testHelpers'

describe('API Authentication', () => {
  let payload: Payload
  let cleanup: () => Promise<void>
  let testUser: User
  let testClient: Client
  let apiKey: string

  beforeAll(async () => {
    const testEnv = await createTestEnvironment()
    payload = testEnv.payload
    cleanup = testEnv.cleanup

    // Create test user
    testUser = await payload.create({
      collection: 'users',
      data: {
        email: 'api-test-manager@example.com',
        password: 'password123',
      },
    }) as User

    // Create test client
    testClient = await payload.create({
      collection: 'clients',
      data: {
        name: 'API Test Client',
        description: 'Client for API authentication testing',
        role: 'full-access',
        managers: [testUser.id],
        primaryContact: testUser.id,
        active: true,
      },
    }) as Client

    // Generate API key for the client
    const response = await payload.update({
      collection: 'clients',
      id: testClient.id,
      data: {
        enableAPIKey: true,
      },
    })
    
    // Note: In a real scenario, the API key would be returned after generation
    // For testing purposes, we'll simulate this
    apiKey = 'test-api-key-12345' // This would normally be generated by Payload
  })

  afterAll(async () => {
    await cleanup()
  })

  describe('API Key Authentication', () => {
    it('authenticates with valid API key', async () => {
      // Create a request with API key header
      const req = {
        headers: {
          authorization: `clients API-Key ${apiKey}`,
        },
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // The authentication would be handled by Payload's auth system
      expect(req.headers.authorization).toContain('clients API-Key')
      expect(req.user.collection).toBe('clients')
    })

    it('rejects invalid API key format', async () => {
      const req = {
        headers: {
          authorization: 'Invalid-Format',
        },
      } as PayloadRequest

      // Invalid format should be rejected by Payload's auth system
      expect(req.headers.authorization).not.toMatch(/^clients API-Key/)
    })

    it('rejects inactive clients', async () => {
      const inactiveClient = await payload.create({
        collection: 'clients',
        data: {
          name: 'Inactive Client',
          role: 'full-access',
          managers: [testUser.id],
          primaryContact: testUser.id,
          active: false,
        },
      }) as Client

      // Inactive clients should not be able to authenticate
      expect(inactiveClient.active).toBe(false)
    })
  })

  describe('Read-Only Access Control', () => {
    let testTag: any

    beforeAll(async () => {
      // Create test data - using tags instead of meditations since meditations require file upload
      testTag = await payload.create({
        collection: 'tags',
        data: {
          title: 'Test Tag for API Access',
        },
      })
    })

    it('allows read operations for API clients', async () => {
      // Simulate an API client request
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // Read operation should be allowed
      const result = await payload.find({
        collection: 'tags',
        req: clientReq,
      })

      expect(result).toBeDefined()
      expect(result.docs).toBeDefined()
    })

    it('prevents create operations for API clients', async () => {
      // Simulate an API client request
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // Create operation should be denied
      await expect(
        payload.create({
          collection: 'tags',
          data: {
            title: 'Should Not Create',
          },
          req: clientReq,
        })
      ).rejects.toThrow()
    })

    it('prevents update operations for API clients', async () => {
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // Update operation should be denied
      await expect(
        payload.update({
          collection: 'tags',
          id: testTag.id,
          data: {
            title: 'Should Not Update',
          },
          req: clientReq,
        })
      ).rejects.toThrow()
    })

    it('prevents delete operations for API clients', async () => {
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // Delete operation should be denied
      await expect(
        payload.delete({
          collection: 'tags',
          id: testTag.id,
          req: clientReq,
        })
      ).rejects.toThrow()
    })
  })

  describe('Collection Access Restrictions', () => {
    it('blocks API client access to users collection', async () => {
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // API clients should not be able to access users collection
      await expect(
        payload.find({
          collection: 'users',
          req: clientReq,
        })
      ).rejects.toThrow()
    })

    it('blocks API client access to clients collection', async () => {
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // API clients should not be able to access clients collection
      await expect(
        payload.find({
          collection: 'clients',
          req: clientReq,
        })
      ).rejects.toThrow()
    })

    it('allows API client read access to other collections', async () => {
      const clientReq = {
        user: {
          id: testClient.id,
          collection: 'clients',
          active: true,
        },
      } as PayloadRequest

      // Test various collections
      const collectionsToTest = ['tags', 'narrators', 'music', 'frames']

      for (const collectionSlug of collectionsToTest) {
        const result = await payload.find({
          collection: collectionSlug,
          req: clientReq,
        })

        expect(result).toBeDefined()
        expect(result.docs).toBeDefined()
      }
    })
  })
})